---
title: "Using the CVEK R package"
author: "Wenying Deng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using the CVEK R package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Short Description

Using a library of base kernels, **CVEK** learns the  generating function from data by directly minimizing the ensemble model's error, and tests whether the data is generated by the RKHS under the null hypothesis. Part I presents a simple example to conduct Gaussian process regression and hypothesis testing using  *cvek* function on simulated data. And Part II shows a real-world application where we use **CVEK** to understand whether the per capita crime rate impacts the relationship between the local socioeconomic status and the housing price at Boston, MA, U.S.A.

Download the package from CRAN or [GitHub](https://github.com/IrisTeng/CVEK-1) and then install and load it.

```{r, message = FALSE}
# devtools::install_github("IrisTeng/CVEK-1")
library(CVEK)
library(ggplot2)
library(ggrepel)
```


## Tutorial using simulation dataset

### Generate Data and Define Model

We generate a simulation dataset using $"rbf"$ kernel with length-scale $1$, and set the relative interaction strength to be $0.2$. The outcome $y_i$ is generated as,
\begin{align*}
y_i=h_1(\mathbf{x}_{i, 1})+h_2(\mathbf{x}_{i, 2})+0.2 * h_{12}(\mathbf{x}_{i, 1}, \mathbf{x}_{i, 2})+\epsilon_i,
\end{align*}
where $h_1$, $h_2$, $h_{12}$ are sampled from RKHSs $\textit{H}_1$, $\textit{H}_2$, $\textit{H}_{12}$, generated using the corresponding *rbf* kernel. We standardize all sampled functions to have unit form, so that $0.2$ represents the strength of interaction relative to the main effect.

```{r}
set.seed(0726)
n <- 150 # including training and test
d <- 4
int_effect <- 0.2
data <- matrix(rnorm(n * d), ncol = d)
Z1 <- data[, 1:2]
Z2 <- data[, 3:4]

kern <- generate_kernel(method = "rbf", l = 1)
w <- rnorm(n)
w12 <- rnorm(n)
K1 <- kern(Z1, Z1)
K2 <- kern(Z2, Z2)
K1 <- K1 / sum(diag(K1)) # standardize kernel
K2 <- K2 / sum(diag(K2))
h0 <- K1 %*% w + K2 %*% w
h0 <- h0 / sqrt(sum(h0 ^ 2)) # standardize main effect

h1_prime <- (K1 * K2) %*% w12 # interaction effect

# standardize sampled functions to have unit norm, so that 0.2
# represents the interaction strength relative to main effect
Ks <- svd(K1 + K2)
len <- length(Ks$d[Ks$d / sum(Ks$d) > .001])
U0 <- Ks$u[, 1:len]
h1_prime_hat <- fitted(lm(h1_prime ~ U0))
h1 <- h1_prime - h1_prime_hat

h1 <- h1 / sqrt(sum(h1 ^ 2)) # standardize interaction effect
Y <- h0 + int_effect * h1 + rnorm(1) + rnorm(n, 0, 0.01)
data <- as.data.frame(cbind(Y, Z1, Z2))
colnames(data) <- c("y", paste0("z", 1:d))

data_train <- data[1:100, ]
data_test <- data[101:150, ]
```


Let's see what the data looks like.

```{r, results='asis'}
knitr::kable(head(data_train, 5))
```


Now we can apply *cvek* function to conduct Gaussian process regression. Below is a detailed list of all the arguments of the function *cvek*.

```{r, fig.width=14, fig.height=11}
knitr::include_graphics("table1.pdf", auto_pdf = TRUE)
```


Suppose we want our kernel library to contain three kernels: $"linear"$, $"polynomial"$ with $p=2$, and $"rbf"$ with $l=1$ (the effective parameter for $"polynomial"$ is $p$ and the effective 
parameter for $"rbf"$ is $l$, so we can set anything to $l$ for $"polynomial"$ kernel and $p$ for
$"rbf"$ kernel), apply *define_library*.

```{r}
kern_par <- data.frame(method = c("linear", "polynomial", "rbf"), 
                       l = rep(1, 3), p = 1:3, stringsAsFactors = FALSE)
# define kernel library
kern_func_list <- define_library(kern_par)
```

And the null model is $y \sim z1 + z2 + k(z3, z4)$.
```{r}
formula <- y ~ z1 + z2 + k(z3, z4)
```



### Estimation and Testing

With all these parameters specified, we can conduct Gaussian process regression.

```{r}
est_res <- cvek(formula, kern_func_list = kern_func_list, 
                data = data_train)
est_res$lambda
est_res$u_hat
```

We can see that there are three elements in $beta$ with the first one as the intercept. More
importantly, the ensemble weight assigns $1$ to the $"rbf"$ kernel, which is the true kernel. 
This illustrates the accuracy and efficiency of the CVEK method.

Then, here comes the testing procedure. 

Note that we can use the same function *cvek* as estimation to perform hypothesis testing, but we need to provide $formula\_test$, which is the user-supplied formula indicating the alternative 
effect to test.

Now, we want to conduct score test with $test="boot"$ and $B=200$ since the sample $n=100$ is small.

```{r}
formula_test <- y ~ k(z1, z2):k(z3, z4)
pvalue <- cvek(formula, kern_func_list = kern_func_list, 
               data = data_train, formula_test = formula_test,
               mode = "loocv", strategy = "stack",
               beta_exp = 1, lambda = exp(seq(-10, 5)),
               test = "boot", alt_kernel_type = "linear",
               B = 200, verbose = FALSE)$pvalue
pvalue
```

So at the significance level $0.05$, we reject the null hypothesis that there's no interaction effect, which matches our data generation mechanism.


Additionally, we can prediction new outcomes based on estimation result *est_res*.

```{r}
y_pred <- predict(est_res, data_test[, 2:5])
data_test_pred <- cbind(y_pred, data_test)
```


```{r, echo=FALSE, results='asis'}
knitr::kable(head(data_test_pred, 5))
```


## Detecting Nonlinear Interaction in Boston Housing Price

In this section, we show an example of using *cvek* test to detect the nonlinear interactions between socioeconomic factors that contribute to housing price in the city of Boston,  Mass, USA. We consider the *Boston* dataset that is available in the **MASS** package in R. *Boston* is  collected by the U.S Census Service about the median housing price ($medv$) in Boston, along with additional variables describing local socioeconomic information such as per capita crime rate, proportion of non-retail business, number of rooms per household, etc.

We use *cvek* to study whether the per capita crime rate ($crim$) impacts the relationship between the local socioeconomic status ($lstat$) and the housing price. Table 2 lists all the $14$ variables. The following covariates are included to adjust for confounding: $zn, indus, chas, nox, rm, age, dis, rad, tax, ptratio$ and $black$, which are modeled as linear effects. 

```{r, fig.width=14, fig.height=3}
knitr::include_graphics("table2.pdf", auto_pdf = TRUE)
```

The null model is,
\begin{align*}
medv \sim \mathbf{x}^\top \boldsymbol{\beta} + k(crim) + k(lstat),
\end{align*}
where $\mathbf{x}^\top=(1, zn, indus, chas, nox, rm, age, dis, rad, tax, ptratio, black)$, and $k()$ is the estimated ensemble kernel matrix, with weights estimated using *cvek*. Therefore, $k()$ is defined by the user-specified model library. Here we specify the model library as *linear* and *rbf* with $l=1$. This inclusion of nonlinearity (i.e. *rbf* kernel) is important, since these socioeconomic attributes are known to have nonlinear association with housing price in the macroeconmics literature [harrison_hedonic_1978](https://doi.org/10.1016/0095-0696(78)90006-2).

```{r}
kern_par <- data.frame(method = c("linear", "rbf"), 
                       l = rep(1, 2), p = 1:2, 
                       stringsAsFactors = FALSE)
# define kernel library
kern_func_list <- define_library(kern_par)
```

To this end, the hypothesis regarding whether $crim$ impacts the $medv - lstat$ relationship is equivalent to testing whether there exists a nonlinear interaction between $crim$ and $lstat$ in predicting $medv$, i.e.,

\begin{align*}
\Hsc_0: &\; medv \sim \mathbf{x}^\top \boldsymbol{\beta} + k(crim) + k(lstat), \\
\Hsc_a: &\; medv \sim \mathbf{x}^\top \boldsymbol{\beta} + k(crim) + k(lstat) + k(crim):k(lstat).
\end{align*}

In the *cvek* implementation, we specify the null model using *formula*, and specify the additional interaction term ($k(crim):k(lstat)$) in the alternative model using *formula\_test*, as shown below:

```{r}
formula <- medv ~ zn + indus + chas + nox + rm + age + dis + 
  rad + tax + ptratio + black + k(crim) + k(lstat)
formula_test <- medv ~ k(crim):k(lstat)
fit_bos <- cvek(formula, kern_func_list = kern_func_list, data = Boston, 
                formula_test = formula_test, 
                lambda = exp(seq(-3, 5)), test = "asymp")
fit_bos$pvalue
```

As shown, since $p<0.05$, we reject the null hypothesis that there's no interaction effect between $crim$ and $lstat$, and conclude that the data does seem to suggest an impact of crime rate on the relationship between local socioeconomic status and housing price.

A versatile and sometimes the most interpretable method for understanding interaction effects is via plotting. 

```{r message=FALSE}
# first fit the alternative model
formula_alt <- medv ~ zn + indus + chas + nox + rm + age + dis + 
  rad + tax + ptratio + black + k(crim):k(lstat)
fit_bos_alt <- cvek(formula = formula_alt, kern_func_list = kern_func_list, 
                    data = Boston, lambda = exp(seq(-3, 5)))

# mean-center all confounding variables not involved in the interaction 
# so that the predicted values are more easily interpreted
pred_name <- c("zn", "indus", "chas", "nox", "rm", "age", 
               "dis", "rad", "tax", "ptratio", "black")
covar_mean <- apply(Boston, 2, mean)
pred_cov <- covar_mean[pred_name]
pred_cov_df <- t(as.data.frame(pred_cov))
lstat_list <- seq(12.5, 17.5, length.out = 100)
crim_quantiles <- quantile(Boston$crim, probs = c(.05, .25, .5, .75, .95))

# crim is set to its 5% quantile
data_test1 <- data.frame(pred_cov_df, lstat = lstat_list, 
                             crim = crim_quantiles[1])
data_test1_pred <- predict(fit_bos_alt, data_test1)

# crim is set to its 25% quantile
data_test2 <- data.frame(pred_cov_df, lstat = lstat_list, 
                             crim = crim_quantiles[2])
data_test2_pred <- predict(fit_bos_alt, data_test2)

# crim is set to its 50% quantile
data_test3 <- data.frame(pred_cov_df, lstat = lstat_list, 
                             crim = crim_quantiles[3])
data_test3_pred <- predict(fit_bos_alt, data_test3)

# crim is set to its 75% quantile
data_test4 <- data.frame(pred_cov_df, lstat = lstat_list, 
                             crim = crim_quantiles[4])
data_test4_pred <- predict(fit_bos_alt, data_test4)

# crim is set to its 95% quantile
data_test5 <- data.frame(pred_cov_df, lstat = lstat_list, 
                             crim = crim_quantiles[5])
data_test5_pred <- predict(fit_bos_alt, data_test5)

# combine five sets of prediction data together
medv <- rbind(data_test1_pred, data_test2_pred, data_test3_pred, 
              data_test4_pred, data_test5_pred)
data_pred <- data.frame(lstat = rep(lstat_list, 5), medv = medv, 
                        crim = c("5% quantile", "25% quantile", 
                                 "50% quantile", "75% quantile", 
                                 "95% quantile"))
data_pred$crim <- factor(data_pred$crim, 
                         levels = c("5% quantile", "25% quantile", 
                                    "50% quantile", "75% quantile", 
                                    "95% quantile"))

data_label <- data_pred[which(data_pred$lstat == 17.5), ]
data_label$value <- c("0.028%", "0.082%", "0.257%", "3.677%", "15.789%")
data_label$value <- factor(data_label$value, levels = 
                             c("0.028%", "0.082%", "0.257%", 
                               "3.677%", "15.789%"))
    
ggplot(data = data_pred, aes(x = lstat, y = medv, color = crim)) + 
  geom_point(size = 0.1) + 
  geom_text_repel(aes(label = value), data = data_label, 
                  color = "black", size = 3.6) + 
    scale_colour_manual(values = c("firebrick1", "chocolate2", 
                                   "darkolivegreen3", "skyblue2", 
                                   "purple2")) + 
  geom_line(col = "firebrick1", data = data_pred[1:100, ]) + 
  geom_line(col = "chocolate2", data = data_pred[101:200, ]) + 
  geom_line(col = "darkolivegreen3", data = data_pred[201:300, ]) + 
  geom_line(col = "skyblue2", data = data_pred[301:400, ]) + 
  geom_line(col = "purple2", data = data_pred[401:500, ]) + 
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 12), 
        legend.title = element_text(size = 12, face = "bold"), 
        legend.text = element_text(size = 12)) + 
    labs(x = "percentage of lower status", 
         y = "median value of owner-occupied homes ($1000)")
```

We visualize the interaction effects by creating five datasets: Fix all confounding variables to their means, vary $lstat$ in a reasonable range (i.e., from $12.5$ to $17.5$, since the original range of $lstat$ in *Boston* dataset is $(1.73, 37.97)$), and respectively set $crim$ value to its $5\%, 25\%, 50\%, 75\%$ and $95\%$ quantiles. Numbers at the end of each curves indicate the actual values of $crim$ rate (per capita crime rate by town) at the corresponding quantiles. From the figure we see that crime rate does impact the relationship between local socioeconomic status and housing price.


## References

1.  Jeremiah Zhe Liu and Brent Coull. Robust Hypothesis Test for Nonlinear Effect       with Gaussian Processes. October 2017.
1.  Xiang Zhan, Anna Plantinga, Ni Zhao, and Michael C. Wu. A fast small-sample         kernel inde- pendence test for microbiome community-level association analysis.     December 2017.
1.  Arnak S. Dalalyan and Alexandre B. Tsybakov. Aggregation by Exponential             Weighting and Sharp Oracle Inequalities. In Learning Theory, Lecture Notes in       Computer Science, pages 97– 111. Springer, Berlin, Heidelberg, June 2007.
1.  Arnab Maity and Xihong Lin. Powerful tests for detecting a gene effect in the       presence of possible gene-gene interactions using garrote kernel machines.          December 2011.
1.  The MIT Press. Gaussian Processes for Machine Learning, 2006.
1.  Xihong Lin. Variance component testing in generalised linear models with random     effects. June 1997.
1.  Philip S. Boonstra, Bhramar Mukherjee, and Jeremy M. G. Taylor. A Small-Sample      Choice of the Tuning Parameter in Ridge Regression. July 2015.
1.  Trevor Hastie, Robert Tibshirani, and Jerome Friedman. The Elements of              Statistical Learning: Data Mining, Inference, and Prediction, Second Edition.       Springer Series in Statistics. Springer- Verlag, New York, 2 edition, 2009.
1.  Hirotogu Akaike. Information Theory and an Extension of the Maximum Likelihood      Princi- ple. In Selected Papers of Hirotugu Akaike, Springer Series in              Statistics, pages 199–213. Springer, New York, NY, 1998.
1.  Clifford M. Hurvich and Chih-Ling Tsai. Regression and time series model            selection in small samples. June 1989.
1.  Hurvich Clifford M., Simonoff Jeffrey S., and Tsai Chih-Ling. Smoothing             parameter selection in nonparametric regression using an improved Akaike            information criterion. January 2002.
